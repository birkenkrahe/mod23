#+title: Modeling - Framework and Falling Penny myth
#+startup: overview hideblocks indent inlineimages
#+property: header-args:R :results output :noweb yes
#+property: header-args:python :results output :noweb yes
#+options: toc:1 num:1
* README

- What are models?
- What are complex systems?
- What is the modeling framework?
- First modeling example: Falling Penny Myth

* What are models?

  #+begin_quote
  "Models are formal structures represented in mathematics and
  diagrams that help us understand the world [...] practice modeling
  and you will better understand complex phenomena." (Page, 2021)
  #+end_quote

* Dietrich Dörner's definition of complexity 
** Sources

Book recommendation: Logic of Failure. Recognizing And Avoiding Error
In Complex Situations (1997) - [[https://www.amazon.com/Logic-Failure-Recognizing-Avoiding-Situations/dp/0201479486][Amazon]]

Article (to read): [[http://links.jstor.org/sici?sici=0080-4622%2819900412%29327%3A1241%3C463%3ATLOF%5BD%3E2.0.CO%3B2-X][The Logic of Failure [and Discussion]​]] (1990)

[[https://lyon.instructure.com/courses/1443/assignments/18224][Canvas assignment until September 7, 2.30 pm.]]

** ChatGPT summary

The paper titled "The Logic of Failure" by D. Dörner explores how
humans deal with complex, dynamic, and uncertain systems. The paper
uses computer-simulated scenarios, such as a small town or a Third
World country, to study human behavior in uncertain situations.

Key Points:

1. Adaptability to Uncertainty: Unlike other creatures, humans can
   adapt to uncertainty by forming hypotheses and planning actions.
2. Case Study - West Africa: The paper discusses a simulated case
   study in West Africa where a development aid project led to
   unintended consequences like famine due to overgrazing and other
   factors.
3. Complex Systems: The paper defines a complex system as one with a
   large number of variables that are interdependent. The Moro system
   in West Africa is used as an example.
4. Human Behavior in Complex Systems: Humans often fail to understand
   the interconnectedness of variables in a complex system. They tend
   to focus on immediate problems and neglect long-term effects.
5. Success and Failure: The paper compares the performance of
   executives and students in managing the simulated Moro
   system. Executives performed better, indicating that experience and
   skill play a role in managing complex systems.
6. Common Mistakes: Humans often make mistakes like neglecting
   long-term effects, failing to coordinate different measures, and
   not checking the outcomes of their actions.
7. Psychological Background: The paper explores the psychological
   reasons behind these mistakes, such as the limited capacity for
   conscious information processing and the tendency to guard one's
   own competence.

Recommendations: The paper suggests that one should not only focus on
current problems but also consider possible future developments and
the long-term effects of actions.

** What are complex problems?

Complex systems are made up of constituents. The complexity of the
whole system may elude us - we need a measure (like maximum entropy in
the article by Golan and Harte, 2022), but that implies an
abstraction.

Dörner says: let's keep all variables and characterize them
instead. His checklist requires all of these at once:
1) Problem is [[https://en.wikipedia.org/wiki/Polytely][polytelic]] (characterized by multiple simultaneous
   goals).
2) The variables evolve dynamically (that is they change over time).
3) The variables are interdependent and compounded (they consist of
   different concatenated parts like a name = first name + last name).
4) There is no clear (mathematical) problem definition.
5) There is no single (known) cause and effect.

*** Exercise

Test Dörner's list on these phenomena ([[https://ideaboardz.com/for/Complexity/5050674][ideaboardz]]):
- The development of AI
- Handling Covid
- Handling Climate Change
- Handling Capitalism
- Handling Communism
- Introducing Electric cars
- Fighting zombies

Example AI:
1) Polytely: AI's advocates have simultaneous, different final goals -
   some want to replace humanity by a superintelligence, others only
   want to augment humanity for dirty work, and some fear for
   humanity.
2) Variables relevant to the development of AI evolve dynamically,
   e.g. the capabilities of hardware and software algorithms.
3) Variables are interdependent (e.g. human abilities vs. machine
   abilities), and compounded (e.g. intelligence itself).
4) No clear problem definition: coming up with an intelligence that
   either is or behaves like a human is a clear problem though it
   cannot (yet) be formulated mathematically (in absence of a formula
   for intelligence).
5) No single cause and effect: what drives AI development is not clear
   but since machines do not program themselves, the clear single
   cause of AI development is man and its development is the only
   (direct) effect.

* Modeling framework
#+attr_latex: :width 300px
#+caption: Source: Downey (2023)
[[../img/modeling.png]]

- If modeling is "defined" by the relationships shown in the diagram
  (from Downey's book p.4), where does coding with interactive
  notebooks fit in? More specifically, which parts of the workspace
  play a role in which part of the diagram? ([[https://github.com/birkenkrahe/mod23/blob/main/img/modeling.png][link]])
  #+begin_quote
  1) The workspace is a software system. It can be subjected to
     measurements, which generate data (about the workbook),
     e.g. session time.
  2) The notebook can be used to create a model of a real system:
     e.g. the unicorn data frame (and data set) is an abstraction
     because only certain features (columns) are retained.
  3) The model (data frame) can then be subjected to further analysis,
     e.g. we can build a model to predict the frequency of unicorns in
     industries based on the collected data (what type of model?)
  4) Sticking to the fact that the workspace itself is a system, we
     could predict future session time lengths based on previous
     usage. A lineplot would show the session times over time (that is a
     time series), and linear extrapolation would predict the evolution
     of the session times.
  5) To validate the prediction, further measurements can be taken and
     plotted alongside the prediction.
  #+end_quote

- These three results are the three outcomes of analytics:
  1) descriptive analysis tells us what has already happened;
  2) predictive analysis shows us what could happen;
  3) prescriptive analysis informs us what should happen.

- An alternative model: discuss the differences! ([[https://github.com/birkenkrahe/mod23/blob/main/img/modeling1.png][link]])
  #+attr_latex: :width 300px
  #+caption: Source: Giordano et al. (2014)
  [[../img/modeling1.png]]
  #+begin_quote
  - "Simulation" (from Model to Prediction) is missing
  - "Validation" (from Prediction to Data) goes both ways while
    "interpretation" of a mathematical model only goes one way.
  - System is equivalent to Real-world data but instead of
    "verification" of the predictions or explanations, the first model
    posits measurements to obtain data which enter a feedback loop with
    the predictions.
  - The first model is more general, the second one only deals with
    mathematical modeling of real-world data.
  - Deep learning models for example, which are trained on real-world
    data and can be validated using test data, are not covered here.
  #+end_quote

* Modeling Examples
** Weather forecasting

1. *System:* Earth's atmosphere (layers, temperature gradients,
   pressure differences, wind patterns).
2. *Model*: Computational model representing atmospheric interactions
   (Navier-Stokes PDEs, thermodynamic laws, radiation balance).
3. *Prediction*: Weather forecast (temperature, humidity, chance of
   precipitation).
4. *Data*: Real-time meteorogical data (current temperature, wind speed,
   satellite images).

** Stock market analysis

1. *System:* Stock market (stocks, indices, traders, economic
   indicators like interest rates, unemployment).
2. *Model*: Quantitative models to predict stock prices (Time Series
   forecasting, sentiment analysis, neural nets).
3. *Prediction*: Stock prices or trends.
4. *Data*: Historical stock prices, trading volumes, economic
   indicators, social media sentiment data.

** Epidemic spread   

1. *System:* Population of infected individuals who are exposed to,
   infected with, or recovered from a contagious disease.
2. *Model*: Compartmental SIR model (Susceptible, Infected, Recovered)
   that uses ODEs to describe how individuals move between
   compartments over time.
3. *Prediction*: Project number of individuals in SIR compartments over
   time.
4. *Data*: Actual case counts, hospitalization rates, recovery rates,
   collected from hospitals, labs, public health agencies.

* The Falling Penny Myth

Workspace problem: https://tinyurl.com/FallingPennyMythProblem

*Question:* Would a penny dropped from the top of the Empire State
Building go so fast that it would be embedded in the concrete; or if
it hit a person, would it break their skull?

*Solution 1:* strong assumptions.
#+begin_quote
$v = at$ is the velocity of an object after $t$ seconds.

The distance travelled is $x = at^2 / 2$.

The time until the penny reaches the sidewalk: $t=\sqrt{2x/a}$

For constant gravity $a = 9.8 m/s^2$ and the height of the Empire State
Building $x = 381 m$, we get $t = 8.8s$.

The velocity after that time is $v = 86 m/s$ (190 mph).
#+end_quote

Modeling assumptions: constant gravity (not true, varies with distance
even in classical mechanics), zero air resistance.

*Solution 2:* downward gravitational force and upward drag (or air
resistance) force are opposed and will eventually cancel each other
out so that the object will no longer be accelerated. It has now
reached /terminal velocity/.

Terminal velocity is reached when:
\begin{equation}
 m \cdot g = \frac{1}{2} \cdot C_d \cdot A \cdot \rho \cdot V_t^2 
\end{equation}

Solving for the velocity, we get:
\begin{equation}
 V_t = \sqrt{\frac{2 \cdot m \cdot g}{C_d \cdot A \cdot \rho}}
\end{equation}

Where $m$ is the mass of the object, $g$ is the acceleration due to
gravity, $C_d$ is the drag coefficient (empirical dimensionless weight
depending on the object in relation to the fluid), A is the
cross-sectional area of the object, and $\rho$ is the density of the
fluid through which the object is falling.

Substituting for our penny, this comes out to about 17 m/s or 38 mph
(while a sky diver, for example, will experience 53 m/s or 120 mph).

To see if and how this hurts, watch [[https://youtu.be/sJkdNnHhaoI?si=UBD7pdlJvpdBKIRG][this video]] by MythBusters (Your
Discovery Science, 2015).

So the first model was wrong and not useful to determine the truth of
the myth. The second model is still wrong but it's better and good
enough to refute the myth (via falsification).

Falsification here means: if I make a claim (the myth), and I can find
one empirical example that it is not true, my claim has lost its
generality and will no longer be scientifically valid.

** Computation in Python

Create a variable ~a~ to represent acceleration in meters per second
squared:
#+begin_src python :results silent
  a = 9.8
#+end_src
Create another variable to represent the time for the penny to drop,
let's say 3.4 seconds:
#+begin_src python results silent
  t = 3.4
#+end_src
Now we can compute the velocity ~v~ of the penny after ~t~ seconds
(ignoring air resistance):
#+begin_src python
  v = a * t
  print(v)
#+end_src

#+RESULTS:
: 33.32

What distance ~x~ would the penny travel during that time?
#+begin_src python
  x = a * t**2 / 2
  print(x)
#+end_src

#+RESULTS:
: 56.644

How long would it take for the penny to fall 381 m, the height of the
Empire States building? First, let's store the height in a variable ~h~:
#+begin_src python :results silent
  h = 381
#+end_src

To compute t, we need the square root function. We can import the
function from the NumPy package:
#+begin_src python :results silent
  from numpy import sqrt
#+end_src

Now we can use it to compute ~t~ in seconds:
#+begin_src python
  t = sqrt(2 * h / a)
  print(t)
#+end_src

#+RESULTS:
: 8.817885349720552

Finally, let's calculate the penny's velocity ~v~ in m/s:
#+begin_src python
  v = a * t
  print(v)
#+end_src

#+RESULTS:
: 86.41527642726142

*Exercise:* can you compute the terminal velocity for the penny given
this formula:
\begin{equation}
 V_t = \sqrt{\frac{2 \cdot m \cdot g}{C_d \cdot A \cdot \rho}}
\end{equation}

Where $m$ is the mass of the object ($2.5\times 10^{-3} kg$), $g$ is
the acceleration due to gravity ($9.8 m/s^2$), $C_d$ is the drag
coefficient ($0.47$), A is the cross-sectional area of the object
($2.85\times 10^{-4} m^2$ - a penny has a radius of $9.525 mm$), and
$\rho$ is the density of the fluid through which the object is falling
($1.204 kg/m^3$).

Solution:
#+begin_src python
  # Assign constants
  m = 2.5e-3  # kg
  g = 9.8     # m/s^2
  c_d = 0.47    
  A = 2.85e-4 # m^2
  rho = 1.204

  # Compute terminal velocity
  v = sqrt((2 * m * g) / (c_d * A * rho))
  print(v)
#+end_src

#+RESULTS:
: 17.430644182450333

*Exercise*: check the penny area computation computationally.

*Solution:* we need the constant value for $\pi$, or we could
approximate it to 3.14, and the known area formula ($\pi r^2$):
#+begin_src python
  r = 9.525e-3
  A = r**2 * 3.14
  print(A)
  print(f'{round(A*1e4,2):.2f}')
#+end_src

#+RESULTS:
: 0.0002848784625
: 2.85

Let's do it with a higher precision ~pi~ using ~NumPy~:
#+begin_src python
  from numpy import pi
  A = r**2 * pi
  print(A)
  print(f'{round(A*1e4,2):.2f}')  
#+end_src

#+RESULTS:
: 0.0002850229569923425
: 2.85

* References

Dorner D, Nixon P, Rosen D. The Logic of Failure [and
Discussion]. Phil Trans Royal Soc 327(1241):463-473.

Downey AB. Modeling and Simulation in Python. NoStarch
Press; 2023. https://allendowney.github.io/ModSimPy/

Giordano FR, Fox WP, Horton SB. A First Course in Mathematical
Modeling (5e). Cengage Learning 2013.

Google LLC. Google Colaboratory. Accessed August
19, 2023. https://colab.research.google.com

Page S. The Model Thinker. Basic Books: New York. 2021.

Python Software Foundation. Python (Version 3.8.10). Python Software
Foundation. Published 2021. Accessed August
19, 2023. https://www.python.org

